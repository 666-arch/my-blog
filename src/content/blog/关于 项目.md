---
author: Huang Chao
pubDatetime: 2023-03-23T11:18:53Z
modDatetime: 2023-03-24T01:22:56.066Z
title: "关于项目"
featured: true
draft: false
tags:
  - 其他
description: "项目梳理"
---

## 项目1：数字人

### 数字人 AI 集成？

> 它主要业务是通过语音指令匹配关键词，然后输出对应的内容，这个输出方式主要是通过浏览器语音播报的方式。

### 科大讯飞语音 API 的流式传输如何实现？

通过 WebSocket 建立长连接，实时传输音频流数据。将音频流切割 `固定大小数据包`（4KB），通过二进制帧（Binary Frame）发送

#### 分包策略

- 前端应该式通过 MediaRecorder API 去录制的音频
- 通过 `ondatavailable` 事件获取数据库按序发送

### 你怎么去二次集成他们的 API 的？

1. 首先，科大讯飞提供的 流式API 需要我们完成接口鉴权，这一步需要提供两个信息

- APIKey
- APISecret
  这两个可以在应用控制台通过创建 WebAPI 应用就可以获取到。

2. 鉴权成功后

检查 `socket` readyState 状态是否处于 `OPEN` 状态，然后通过 讯飞提供的格式发送音频流

- status：检查是否是最后一帧
- format：音频采样率确定
- encoding：音频格式，`raw` 原生音频
- audio：音频内容，将请求参数使用 `base64` 编码

```js
const params = {
  common: {
    app_id: this.APP_ID, // 应用ID，可在讯飞控制台获取
  },
  business: {
    language: "zh_cn", //设置返回的语音语言
    domain: "iat",
    accent: "mandarin", //接收的语音
    vad_eos: 60000, // 静默状态时长(测试最长静默时间为60s)
    dwa: "wpgs",
    ptt: 0, //不要识别标点符号
  },
  data: {
    status: 0,
    format: "audio/L16;rate=16000", //采样率
    encoding: "raw", //原生音频格式
  },
};
this.ws?.send(JSON.stringify(params));
```

3. 获取音频文本

- 科大讯飞返回的是 `多数组单字符` 的数据结构，通过字段 `pgs` 判断是否是文本片段
- 然后通过循环和累加的方式每次获取的都是最新的文本

4. 向外暴露音频文本结果

- 通过 `Events` 库，将集成类继承 `EventEmitter`
- 它可以实现类似 `订阅发布` 模式，通过 `set` 和 `get` 去添加监听事件，将最新的结果发送给外部组件
- 外部组件去通过回调函数监听，接收结果参数，拿到最新的结果

### 怎么去实现 socket 状态轮询的？

> 通过 socket 的 `onClose` 回调，记录一个状态，如果当前ws连接池是关闭状态，就向外派发一个回调，组件监听
> 这个回调，判断状态是否处于关闭，如果关闭就重新创建连接

#### 注意：这里 api 只会初始化一次，断开连接后只会重新连接，而不会初始化整个接口

### Map 映射表怎么去匹配命令的？

`动名词划分`

根据正则，去划分哪些是动词，哪些是名词，比如 "跳转到首页"，其中 `跳转` 就是动词，`首页` 就是名词

```regexp
"跳转首页”.match(/[打开|切换|跳转]+[到]?([\u4e00-\ugfa5]+)/)
```

这样可以省略很多重复命令词

#### 播报数据是怎么去存储的？全局状态管理？

- 通过 `zustand`
  针对需要播报的接口，将数据通过全局状态管理存储，在命令匹配成功后，这样直接去读取动态数据

### 你是怎么去动态替换模板数据的？

通过全局模板字符串处理函数
接收两个参数：

- 通过 `${data}` 去构建的模板字符串
- 需要替换的数据源（来自接口）
- 通过正则去匹配需要替换的数据
- 通过 replace 替换模板
- 返回替换完的数据

```ts
export function replacePlaceholders(template: string, data: any) {
  return Object.keys(data).reduce((str, key) => {
    // 替换占位符
    const regex = new RegExp(`{${key}}`, "g");
    return str.replace(regex, data[key]);
  }, template);
}
```

### 为什么状态管理选择 zustand？

- 相比 redux 数据走向，zustand 更容易理解和维护
- 代码量少

## 项目2：大屏可视化

### Echarts 封装优化怎么处理的？

- 配置抽象化处理
  - 拆分出 Echarts 的 `option` 基础配置（如坐标轴、图例、颜色）和 业务配置（数据映射data）
  - 通过 Props 和 UseEffect 依赖去监听数据的变化
  - 通过 `useRef` 绑定渲染的 echarts 面板，通过 `current` 属性配置 `setOption`
